---
// 简化版 AudioPlayer - 保留完全相同的外部接口和DOM结构
// v2.0 - 移除AudioPlayerManager依赖，内部实现简化

import { Card, CardContent } from "@/components/ui/card"
import AudioPlayerSkeleton from '../AudioPlayerSkeleton.astro';
import AudioPlayerControls from './AudioPlayerControls.astro';
import AudioPlayerProgress from './AudioPlayerProgress.astro';
import AudioPlayerTime from './AudioPlayerTime.astro';
import AudioPlayerError from './AudioPlayerError.astro';

export interface Props {
  audioSrc: string;
  title?: string;
  autoplay?: boolean;
  showProgress?: boolean;
  className?: string;
  useSlider?: boolean;
  loading?: boolean;
  showErrorDetails?: boolean;
}

const {
  audioSrc,
  title = "Audio Track",
  autoplay = false,
  showProgress = true,
  className = "",
  useSlider = false,
  loading = false,
  showErrorDetails = false
} = Astro.props;

const uniqueId = `audio-player-${Math.random().toString(36).slice(2, 11)}`;
---

{loading ? (
  <AudioPlayerSkeleton
    title={title}
    showProgress={showProgress}
    className={className}
  />
) : (
  <Card
    className={`audio-player audio-player-card ${className}`}
    data-audio-id={uniqueId}
    role="region"
    aria-labelledby={`audio-title-${uniqueId}`}
     aria-describedby={showProgress ? `current-time-${uniqueId} duration-${uniqueId}` : undefined}
  >
    <CardContent className="p-4 sm:p-6">
      <div class="flex items-center space-x-3 sm:space-x-4">
        <!-- Play/Pause Controls -->
        <AudioPlayerControls
          uniqueId={uniqueId}
          title={title}
        />

        <!-- Progress Bar and Time Display -->
        <div class="flex-1 flex items-center space-x-2 sm:space-x-3">
          <AudioPlayerProgress
            uniqueId={uniqueId}
            showProgress={showProgress}
            useSlider={useSlider}
            className="flex-1"
          />

          <AudioPlayerTime
            uniqueId={uniqueId}
            showTime={showProgress}
          />
        </div>
      </div>

      <!-- Track Title -->
      <div class="mt-3">
        <h3
          id={`audio-title-${uniqueId}`}
          class="text-sm font-medium text-foreground truncate"
        >
          {title}
        </h3>

        <!-- Screen reader status -->
        <div
          id={`audio-status-${uniqueId}`}
          class="sr-only"
          aria-live="polite"
        >
          Ready to play
        </div>
      </div>

      <!-- Error Handling -->
      <AudioPlayerError
        uniqueId={uniqueId}
        showErrorDetails={showErrorDetails}
      />

      <!-- Hidden Audio Element -->
      <audio
        id={uniqueId}
        preload="metadata"
        class="hidden"
        {autoplay}
        aria-label={`Audio player for ${title}`}
      >
        <source src={audioSrc} />
        Your browser does not support the audio element.
      </audio>
    </CardContent>
  </Card>
)}

<style>
  .audio-player-card {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .audio-player-card:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .audio-player-card.playing {
    border-color: hsl(var(--primary) / 0.5);
    box-shadow: 0 0 0 1px hsl(var(--primary) / 0.2), 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .audio-player-card.error {
    border-color: hsl(var(--destructive) / 0.3);
    background-color: hsl(var(--destructive) / 0.02);
  }

  /* Responsive adjustments */
  @media (max-width: 640px) {
    .audio-player-card {
      margin: 8px 0;
    }

    .audio-player-card .space-x-3 > :not([hidden]) ~ :not([hidden]) {
      margin-left: 8px;
    }

    .audio-player-card .space-x-4 > :not([hidden]) ~ :not([hidden]) {
      margin-left: 8px;
    }
  }

  /* High contrast mode */
  @media (prefers-contrast: high) {
    .audio-player-card {
      border-width: 2px;
    }

    .audio-player-card.playing {
      border-width: 3px;
    }
  }

  /* Focus management */
  .audio-player-card:focus-within {
    outline: 2px solid hsl(var(--primary));
    outline-offset: 2px;
  }

  /* Reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .audio-player-card {
      transition: none;
    }

    .audio-player-card:hover {
      transform: none;
    }
  }
</style>

<script>
  // 简化的内联音频播放器实现 - 不依赖 AudioPlayerManager
  class SimpleAudioPlayer {
    constructor(audioId: string) {
      const card = document.querySelector(`[data-audio-id="${audioId}"]`);
      if (!card) return;

      const audio = document.getElementById(audioId) as HTMLAudioElement;
      const button = card.querySelector('.audio-play-btn') as HTMLElement;
      const progressBar = card.querySelector('.audio-progress-bar') as HTMLElement;
      const currentTimeSpan = card.querySelector('.audio-current-time') as HTMLElement;
      const durationSpan = card.querySelector('.audio-duration') as HTMLElement;
      const errorMessage = card.querySelector('.audio-error-message') as HTMLElement;
      const errorDetails = card.querySelector('.audio-error-details') as HTMLElement;
      const errorText = card.querySelector('.audio-error-text') as HTMLElement;
      const retryBtn = card.querySelector('.audio-retry-btn') as HTMLElement;
      const statusElement = card.querySelector(`#audio-status-${audioId}`) as HTMLElement;
      const fallbackProgressBar = card.querySelector('.fallback-progress-bar') as HTMLElement;

      if (!audio || !button) return;

      // Format time helper
      const formatTime = (seconds: number) => {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      // Update duration when metadata loads
      audio.addEventListener('loadedmetadata', () => {
        if (durationSpan) {
          durationSpan.textContent = formatTime(audio.duration);
        }
      });

      audio.addEventListener('loadstart', () => {
        button.classList.add('loading');
      });

      audio.addEventListener('canplaythrough', () => {
        button.classList.remove('loading');
        this.clearErrorState(card, errorMessage, errorDetails);
        if (durationSpan && audio.duration) {
          durationSpan.textContent = formatTime(audio.duration);
        }
      });

      // Update progress
      audio.addEventListener('timeupdate', () => {
        const percent = (audio.currentTime / audio.duration) * 100;
        if (progressBar) {
          progressBar.style.width = `${percent}%`;
        }
        if (fallbackProgressBar) {
          fallbackProgressBar.style.width = `${percent}%`;
        }
        if (currentTimeSpan) {
          currentTimeSpan.textContent = formatTime(audio.currentTime);
        }
      });

      // Handle play/pause
      button.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();

        if (audio.paused) {
          // Stop other players
          document.querySelectorAll('audio').forEach(a => {
            if (a !== audio && !a.paused) {
              a.pause();
              const otherCard = a.closest('.audio-player-card');
              const otherButton = otherCard?.querySelector('.audio-play-btn');
              otherCard?.classList.remove('playing');
              otherButton?.classList.remove('playing');
            }
          });

          audio.play().catch(err => {
            console.error('Audio play failed:', err);
            this.showErrorState(card, errorMessage, errorDetails, errorText, err.message);
          });

          card.classList.add('playing');
          button.classList.add('playing');
          button.setAttribute('aria-label', 'Pause');
          if (statusElement) {
            statusElement.textContent = 'Playing';
          }
        } else {
          audio.pause();
          card.classList.remove('playing');
          button.classList.remove('playing');
          button.setAttribute('aria-label', 'Play');
          if (statusElement) {
            statusElement.textContent = 'Paused';
          }
        }
      });

      // Handle ended
      audio.addEventListener('ended', () => {
        card.classList.remove('playing');
        button.classList.remove('playing');
        button.setAttribute('aria-label', 'Play');
        if (progressBar) {
          progressBar.style.width = '0%';
        }
        if (fallbackProgressBar) {
          fallbackProgressBar.style.width = '0%';
        }
        if (currentTimeSpan) {
          currentTimeSpan.textContent = '0:00';
        }
        if (statusElement) {
          statusElement.textContent = 'Ended';
        }
      });

      // Handle errors
      audio.addEventListener('error', (e) => {
        const audioError = e.target as HTMLAudioElement;
        const errorMsg = audioError?.error
          ? `MediaError code: ${audioError.error.code}`
          : 'Audio loading failed';

        button.classList.remove('loading');
        this.showErrorState(card, errorMessage, errorDetails, errorText, errorMsg);
      });

      // Retry button
      if (retryBtn) {
        retryBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.clearErrorState(card, errorMessage, errorDetails);
          audio.load();
          audio.play().catch(err => {
            this.showErrorState(card, errorMessage, errorDetails, errorText, err.message);
          });
        });
      }
    }

    private clearErrorState(card: Element, errorMessage: Element | null, errorDetails: Element | null) {
      card.classList.remove('error');
      if (errorMessage) {
        errorMessage.classList.add('hidden');
      }
      if (errorDetails) {
        errorDetails.classList.add('hidden');
      }
    }

    private showErrorState(
      card: Element,
      errorMessage: Element | null,
      errorDetails: Element | null,
      errorText: Element | null,
      message: string
    ) {
      card.classList.add('error');
      card.classList.remove('playing');
      if (errorMessage) {
        errorMessage.classList.remove('hidden');
      }
      if (errorDetails) {
        errorDetails.classList.remove('hidden');
      }
      if (errorText) {
        errorText.textContent = message;
      }
    }
  }

  // Initialize audio players when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const audioCards = document.querySelectorAll('.audio-player-card[data-audio-id]');
    audioCards.forEach((card) => {
      const audioId = (card as HTMLElement).dataset.audioId;
      if (audioId) {
        new SimpleAudioPlayer(audioId);
      }
    });
  });

  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    document.querySelectorAll('audio').forEach(audio => {
      if (!audio.paused) {
        audio.pause();
      }
    });
  });
</script>
